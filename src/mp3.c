/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *   Mupen64plus-rsp-hle - mp3.c                                           *
 *   Mupen64Plus homepage: http://code.google.com/p/mupen64plus/           *
 *   Copyright (C) 2012 Bobby Smiles                                       *
 *   Copyright (C) 2009 Richard Goedeken                                   *
 *   Copyright (C) 2002 Hacktarux                                          *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include "hle.h"
#include "m64p_types.h"

#include "mp3.h"

static u8 mp3data[0x1000];

static const unsigned REORDERED_OFFSETS[16] = 
{
    0x00, 0x02, 0x06, 0x04, 0x0e, 0x0c, 0x08, 0x0a,
    0x1e, 0x1c, 0x18, 0x1a, 0x10, 0x12, 0x16, 0x14
};

/* {2*cos((2k+1)PI/64)} with k = {0,1,3,2,7,6,4,5,15,14,12,13,8,9,11,10} */
static const s32 C64_ODD[16] =
{
    0x1ff64, 0x1fa74, 0x1e214, 0x1f0a8, 0x17b5c, 0x19b40, 0x1ced8, 0x1b728,
    0x01920, 0x04b20, 0x0ac7c, 0x07c68, 0x157d8, 0x13100, 0x0dae8, 0x10738
};

/* {cos(2*(2k+1)PI/64)} with k = {0,1,3,2,7,6,4,5} */
static const u16 C64_EVEN1[8] =
{
    0xfec4, 0xf4fa, 0xc5e4, 0xe1c4, 0x1916, 0x4a50, 0xa268, 0x78ae
};

/* {cos(2*(2k)PI/64)} with k = {1,3,7,5} */
static const u16 C64_EVEN2[4] = { 0xfb14, 0xd4dc, 0x31f2, 0x8e3a };

/* {cos(2*(2k)PI/64)} with k = {2,6} */
static const u16 C64_EVEN3[2] = { 0xec84, 0x61f8 };

/* {1/sqrt(2), sqrt(2), 2*sqrt(2), 4*sqrt(2) } */
static const s32 K[] = { 0xb504, 0x16a09, 0x2d413, 0x5a827 };

static const u16 WINDOW_LUT[0x420] =
{
    0x0000, 0xfff3, 0x005d, 0xff38, 0x037a, 0xf736, 0x0b37, 0xc00e,
    0x7fff, 0x3ff2, 0x0b37, 0x08ca, 0x037a, 0x00c8, 0x005d, 0x000d,
    0x0000, 0xfff3, 0x005d, 0xff38, 0x037a, 0xf736, 0x0b37, 0xc00e,
    0x7fff, 0x3ff2, 0x0b37, 0x08ca, 0x037a, 0x00c8, 0x005d, 0x000d,
    0x0000, 0xfff2, 0x005f, 0xff1d, 0x0369, 0xf697, 0x0a2a, 0xbce7,
    0x7feb, 0x3ccb, 0x0c2b, 0x082b, 0x0385, 0x00af, 0x005b, 0x000b,
    0x0000, 0xfff2, 0x005f, 0xff1d, 0x0369, 0xf697, 0x0a2a, 0xbce7,
    0x7feb, 0x3ccb, 0x0c2b, 0x082b, 0x0385, 0x00af, 0x005b, 0x000b,
    0x0000, 0xfff1, 0x0061, 0xff02, 0x0354, 0xf5f9, 0x0905, 0xb9c4,
    0x7fb0, 0x39a4, 0x0d08, 0x078c, 0x038c, 0x0098, 0x0058, 0x000a,
    0x0000, 0xfff1, 0x0061, 0xff02, 0x0354, 0xf5f9, 0x0905, 0xb9c4,
    0x7fb0, 0x39a4, 0x0d08, 0x078c, 0x038c, 0x0098, 0x0058, 0x000a,
    0x0000, 0xffef, 0x0062, 0xfee6, 0x033b, 0xf55c, 0x07c8, 0xb6a4,
    0x7f4d, 0x367e, 0x0dce, 0x06ee, 0x038f, 0x0080, 0x0056, 0x0009,
    0x0000, 0xffef, 0x0062, 0xfee6, 0x033b, 0xf55c, 0x07c8, 0xb6a4,
    0x7f4d, 0x367e, 0x0dce, 0x06ee, 0x038f, 0x0080, 0x0056, 0x0009,
    0x0000, 0xffee, 0x0063, 0xfeca, 0x031c, 0xf4c3, 0x0671, 0xb38c,
    0x7ec2, 0x335d, 0x0e7c, 0x0652, 0x038e, 0x006b, 0x0053, 0x0008,
    0x0000, 0xffee, 0x0063, 0xfeca, 0x031c, 0xf4c3, 0x0671, 0xb38c,
    0x7ec2, 0x335d, 0x0e7c, 0x0652, 0x038e, 0x006b, 0x0053, 0x0008,
    0x0000, 0xffec, 0x0064, 0xfeac, 0x02f7, 0xf42c, 0x0502, 0xb07c,
    0x7e12, 0x3041, 0x0f14, 0x05b7, 0x038a, 0x0056, 0x0050, 0x0007,
    0x0000, 0xffec, 0x0064, 0xfeac, 0x02f7, 0xf42c, 0x0502, 0xb07c,
    0x7e12, 0x3041, 0x0f14, 0x05b7, 0x038a, 0x0056, 0x0050, 0x0007,
    0x0000, 0xffeb, 0x0064, 0xfe8e, 0x02ce, 0xf399, 0x037a, 0xad75,
    0x7d3a, 0x2d2c, 0x0f97, 0x0520, 0x0382, 0x0043, 0x004d, 0x0007,
    0x0000, 0xffeb, 0x0064, 0xfe8e, 0x02ce, 0xf399, 0x037a, 0xad75,
    0x7d3a, 0x2d2c, 0x0f97, 0x0520, 0x0382, 0x0043, 0x004d, 0x0007,
    0xffff, 0xffe9, 0x0063, 0xfe6f, 0x029e, 0xf30b, 0x01d8, 0xaa7b,
    0x7c3d, 0x2a1f, 0x1004, 0x048b, 0x0377, 0x0030, 0x004a, 0x0006,
    0xffff, 0xffe9, 0x0063, 0xfe6f, 0x029e, 0xf30b, 0x01d8, 0xaa7b,
    0x7c3d, 0x2a1f, 0x1004, 0x048b, 0x0377, 0x0030, 0x004a, 0x0006,
    0xffff, 0xffe7, 0x0062, 0xfe4f, 0x0269, 0xf282, 0x001f, 0xa78d,
    0x7b1a, 0x271c, 0x105d, 0x03f9, 0x036a, 0x001f, 0x0046, 0x0006,
    0xffff, 0xffe7, 0x0062, 0xfe4f, 0x0269, 0xf282, 0x001f, 0xa78d,
    0x7b1a, 0x271c, 0x105d, 0x03f9, 0x036a, 0x001f, 0x0046, 0x0006,
    0xffff, 0xffe4, 0x0061, 0xfe2f, 0x022f, 0xf1ff, 0xfe4c, 0xa4af,
    0x79d3, 0x2425, 0x10a2, 0x036c, 0x0359, 0x0010, 0x0043, 0x0005,
    0xffff, 0xffe4, 0x0061, 0xfe2f, 0x022f, 0xf1ff, 0xfe4c, 0xa4af,
    0x79d3, 0x2425, 0x10a2, 0x036c, 0x0359, 0x0010, 0x0043, 0x0005,
    0xffff, 0xffe2, 0x005e, 0xfe10, 0x01ee, 0xf184, 0xfc61, 0xa1e1,
    0x7869, 0x2139, 0x10d3, 0x02e3, 0x0346, 0x0001, 0x0040, 0x0004,
    0xffff, 0xffe2, 0x005e, 0xfe10, 0x01ee, 0xf184, 0xfc61, 0xa1e1,
    0x7869, 0x2139, 0x10d3, 0x02e3, 0x0346, 0x0001, 0x0040, 0x0004,
    0xffff, 0xffe0, 0x005b, 0xfdf0, 0x01a8, 0xf111, 0xfa5f, 0x9f27,
    0x76db, 0x1e5c, 0x10f2, 0x025e, 0x0331, 0xfff3, 0x003d, 0x0004,
    0xffff, 0xffe0, 0x005b, 0xfdf0, 0x01a8, 0xf111, 0xfa5f, 0x9f27,
    0x76db, 0x1e5c, 0x10f2, 0x025e, 0x0331, 0xfff3, 0x003d, 0x0004,
    0xffff, 0xffde, 0x0057, 0xfdd0, 0x015b, 0xf0a7, 0xf845, 0x9c80,
    0x752c, 0x1b8e, 0x1100, 0x01de, 0x0319, 0xffe7, 0x003a, 0x0003,
    0xffff, 0xffde, 0x0057, 0xfdd0, 0x015b, 0xf0a7, 0xf845, 0x9c80,
    0x752c, 0x1b8e, 0x1100, 0x01de, 0x0319, 0xffe7, 0x003a, 0x0003,
    0xfffe, 0xffdb, 0x0053, 0xfdb0, 0x0108, 0xf046, 0xf613, 0x99ee,
    0x735c, 0x18d1, 0x10fd, 0x0163, 0x0300, 0xffdc, 0x0037, 0x0003,
    0xfffe, 0xffdb, 0x0053, 0xfdb0, 0x0108, 0xf046, 0xf613, 0x99ee,
    0x735c, 0x18d1, 0x10fd, 0x0163, 0x0300, 0xffdc, 0x0037, 0x0003,
    0xfffe, 0xffd8, 0x004d, 0xfd90, 0x00b0, 0xeff0, 0xf3cc, 0x9775,
    0x716c, 0x1624, 0x10ea, 0x00ee, 0x02e5, 0xffd2, 0x0033, 0x0003,
    0xfffe, 0xffd8, 0x004d, 0xfd90, 0x00b0, 0xeff0, 0xf3cc, 0x9775,
    0x716c, 0x1624, 0x10ea, 0x00ee, 0x02e5, 0xffd2, 0x0033, 0x0003,
    0xfffe, 0xffd6, 0x0047, 0xfd72, 0x0051, 0xefa6, 0xf16f, 0x9514,
    0x6f5e, 0x138a, 0x10c8, 0x007e, 0x02ca, 0xffc9, 0x0030, 0x0003,
    0xfffe, 0xffd6, 0x0047, 0xfd72, 0x0051, 0xefa6, 0xf16f, 0x9514,
    0x6f5e, 0x138a, 0x10c8, 0x007e, 0x02ca, 0xffc9, 0x0030, 0x0003,
    0xfffe, 0xffd3, 0x0040, 0xfd54, 0xffec, 0xef68, 0xeefc, 0x92cd,
    0x6d33, 0x1104, 0x1098, 0x0014, 0x02ac, 0xffc0, 0x002d, 0x0002,
    0xfffe, 0xffd3, 0x0040, 0xfd54, 0xffec, 0xef68, 0xeefc, 0x92cd,
    0x6d33, 0x1104, 0x1098, 0x0014, 0x02ac, 0xffc0, 0x002d, 0x0002,
    0x0030, 0xffc9, 0x02ca, 0x007e, 0x10c8, 0x138a, 0x6f5e, 0x9514,
    0xf16f, 0xefa6, 0x0051, 0xfd72, 0x0047, 0xffd6, 0xfffe, 0x0003,
    0x0030, 0xffc9, 0x02ca, 0x007e, 0x10c8, 0x138a, 0x6f5e, 0x9514,
    0xf16f, 0xefa6, 0x0051, 0xfd72, 0x0047, 0xffd6, 0xfffe, 0x0003,
    0x0033, 0xffd2, 0x02e5, 0x00ee, 0x10ea, 0x1624, 0x716c, 0x9775,
    0xf3cc, 0xeff0, 0x00b0, 0xfd90, 0x004d, 0xffd8, 0xfffe, 0x0003,
    0x0033, 0xffd2, 0x02e5, 0x00ee, 0x10ea, 0x1624, 0x716c, 0x9775,
    0xf3cc, 0xeff0, 0x00b0, 0xfd90, 0x004d, 0xffd8, 0xfffe, 0x0003,
    0x0037, 0xffdc, 0x0300, 0x0163, 0x10fd, 0x18d1, 0x735c, 0x99ee,
    0xf613, 0xf046, 0x0108, 0xfdb0, 0x0053, 0xffdb, 0xfffe, 0x0003,
    0x0037, 0xffdc, 0x0300, 0x0163, 0x10fd, 0x18d1, 0x735c, 0x99ee,
    0xf613, 0xf046, 0x0108, 0xfdb0, 0x0053, 0xffdb, 0xfffe, 0x0003,
    0x003a, 0xffe7, 0x0319, 0x01de, 0x1100, 0x1b8e, 0x752c, 0x9c80,
    0xf845, 0xf0a7, 0x015b, 0xfdd0, 0x0057, 0xffde, 0xffff, 0x0003,
    0x003a, 0xffe7, 0x0319, 0x01de, 0x1100, 0x1b8e, 0x752c, 0x9c80,
    0xf845, 0xf0a7, 0x015b, 0xfdd0, 0x0057, 0xffde, 0xffff, 0x0004,
    0x003d, 0xfff3, 0x0331, 0x025e, 0x10f2, 0x1e5c, 0x76db, 0x9f27,
    0xfa5f, 0xf111, 0x01a8, 0xfdf0, 0x005b, 0xffe0, 0xffff, 0x0004,
    0x003d, 0xfff3, 0x0331, 0x025e, 0x10f2, 0x1e5c, 0x76db, 0x9f27,
    0xfa5f, 0xf111, 0x01a8, 0xfdf0, 0x005b, 0xffe0, 0xffff, 0x0004,
    0x0040, 0x0001, 0x0346, 0x02e3, 0x10d3, 0x2139, 0x7869, 0xa1e1,
    0xfc61, 0xf184, 0x01ee, 0xfe10, 0x005e, 0xffe2, 0xffff, 0x0004,
    0x0040, 0x0001, 0x0346, 0x02e3, 0x10d3, 0x2139, 0x7869, 0xa1e1,
    0xfc61, 0xf184, 0x01ee, 0xfe10, 0x005e, 0xffe2, 0xffff, 0x0005,
    0x0043, 0x0010, 0x0359, 0x036c, 0x10a2, 0x2425, 0x79d3, 0xa4af,
    0xfe4c, 0xf1ff, 0x022f, 0xfe2f, 0x0061, 0xffe4, 0xffff, 0x0005,
    0x0043, 0x0010, 0x0359, 0x036c, 0x10a2, 0x2425, 0x79d3, 0xa4af,
    0xfe4c, 0xf1ff, 0x022f, 0xfe2f, 0x0061, 0xffe4, 0xffff, 0x0006,
    0x0046, 0x001f, 0x036a, 0x03f9, 0x105d, 0x271c, 0x7b1a, 0xa78d,
    0x001f, 0xf282, 0x0269, 0xfe4f, 0x0062, 0xffe7, 0xffff, 0x0006,
    0x0046, 0x001f, 0x036a, 0x03f9, 0x105d, 0x271c, 0x7b1a, 0xa78d,
    0x001f, 0xf282, 0x0269, 0xfe4f, 0x0062, 0xffe7, 0xffff, 0x0006,
    0x004a, 0x0030, 0x0377, 0x048b, 0x1004, 0x2a1f, 0x7c3d, 0xaa7b,
    0x01d8, 0xf30b, 0x029e, 0xfe6f, 0x0063, 0xffe9, 0xffff, 0x0006,
    0x004a, 0x0030, 0x0377, 0x048b, 0x1004, 0x2a1f, 0x7c3d, 0xaa7b,
    0x01d8, 0xf30b, 0x029e, 0xfe6f, 0x0063, 0xffe9, 0xffff, 0x0007,
    0x004d, 0x0043, 0x0382, 0x0520, 0x0f97, 0x2d2c, 0x7d3a, 0xad75,
    0x037a, 0xf399, 0x02ce, 0xfe8e, 0x0064, 0xffeb, 0x0000, 0x0007,
    0x004d, 0x0043, 0x0382, 0x0520, 0x0f97, 0x2d2c, 0x7d3a, 0xad75,
    0x037a, 0xf399, 0x02ce, 0xfe8e, 0x0064, 0xffeb, 0x0000, 0x0007,
    0x0050, 0x0056, 0x038a, 0x05b7, 0x0f14, 0x3041, 0x7e12, 0xb07c,
    0x0502, 0xf42c, 0x02f7, 0xfeac, 0x0064, 0xffec, 0x0000, 0x0007,
    0x0050, 0x0056, 0x038a, 0x05b7, 0x0f14, 0x3041, 0x7e12, 0xb07c,
    0x0502, 0xf42c, 0x02f7, 0xfeac, 0x0064, 0xffec, 0x0000, 0x0008,
    0x0053, 0x006b, 0x038e, 0x0652, 0x0e7c, 0x335d, 0x7ec2, 0xb38c,
    0x0671, 0xf4c3, 0x031c, 0xfeca, 0x0063, 0xffee, 0x0000, 0x0008,
    0x0053, 0x006b, 0x038e, 0x0652, 0x0e7c, 0x335d, 0x7ec2, 0xb38c,
    0x0671, 0xf4c3, 0x031c, 0xfeca, 0x0063, 0xffee, 0x0000, 0x0009,
    0x0056, 0x0080, 0x038f, 0x06ee, 0x0dce, 0x367e, 0x7f4d, 0xb6a4,
    0x07c8, 0xf55c, 0x033b, 0xfee6, 0x0062, 0xffef, 0x0000, 0x0009,
    0x0056, 0x0080, 0x038f, 0x06ee, 0x0dce, 0x367e, 0x7f4d, 0xb6a4,
    0x07c8, 0xf55c, 0x033b, 0xfee6, 0x0062, 0xffef, 0x0000, 0x000a,
    0x0058, 0x0098, 0x038c, 0x078c, 0x0d08, 0x39a4, 0x7fb0, 0xb9c4,
    0x0905, 0xf5f9, 0x0354, 0xff02, 0x0061, 0xfff1, 0x0000, 0x000a,
    0x0058, 0x0098, 0x038c, 0x078c, 0x0d08, 0x39a4, 0x7fb0, 0xb9c4,
    0x0905, 0xf5f9, 0x0354, 0xff02, 0x0061, 0xfff1, 0x0000, 0x000b,
    0x005b, 0x00af, 0x0385, 0x082b, 0x0c2b, 0x3ccb, 0x7feb, 0xbce7,
    0x0a2a, 0xf697, 0x0369, 0xff1d, 0x005f, 0xfff2, 0x0000, 0x000b,
    0x005b, 0x00af, 0x0385, 0x082b, 0x0c2b, 0x3ccb, 0x7feb, 0xbce7,
    0x0a2a, 0xf697, 0x0369, 0xff1d, 0x005f, 0xfff2, 0x0000, 0x000d,
    0x005d, 0x00c8, 0x037a, 0x08ca, 0x0b37, 0x3ff2, 0x7fff, 0xc00e,
    0x0b37, 0xf736, 0x037a, 0xff38, 0x005d, 0xfff3, 0x0000, 0x000d,
    0x005d, 0x00c8, 0x037a, 0x08ca, 0x0b37, 0x3ff2, 0x7fff, 0xc00e,
    0x0b37, 0xf736, 0x037a, 0xff38, 0x005d, 0xfff3, 0x0000, 0x0000
};

/* local functions */
static s16 clamp_s16(s32 x)
{
    if (x > 32767) { x = 32767; } else if (x < -32768) { x = -32768; }
    return x;
}

static s32 mul(s32 x, s32 y)
{
    return (x*y) >> 16;
}

static s32 dmul_round(s16 x, s16 y)
{
    return ((s32)x * (s32)y + 0x4000) >> 15;
}

static void smul(s16 *x, s16 gain)
{
    *x = clamp_s16((s32)(*x) * (s32)gain);
}

static s16* sample_at(u16 mem)
{
    assert((mem & 0x1) == 0);
    assert((mem & ~0xfff) == 0);

    return (s16*)(mp3data+(mem^S16));
}

static void swap(u16 *a, u16 *b)
{
    u16 tmp = *b;
    *b = *a;
    *a = tmp;
}

/* return the address of the index element of FIFO 
 * NOTE: dmem can be any address inside desired FIFO */
static u16 fifo16_address(u16 dmem, unsigned index)
{
    return (dmem & 0xffe0) | (index << 1);
}

static void butterfly(s32 *x, s32 *y, s32 w)
{
    s32 sum  = *x + *y;
    s32 diff = *x - *y;

    *x = sum;
    *y = mul(diff, w);
}

static void idot8(s32 *dot_even, s32 *dot_odd, const s16 *x, const s16 *y)
{
    unsigned i;

    *dot_even = 0;
    *dot_odd  = 0;
    
    for(i = 0; i < 8; ++i)
    {
        *dot_even += dmul_round(*(x++), *(y++));
        *dot_odd  += dmul_round(*(x++), *(y++));
    }
}

static void matrixing_mdct16(s32 *v)
{
    unsigned i;

    /* 1 8-wide butterfly */
    for (i = 0; i < 8; ++i)
        butterfly(&v[0 + i], &v[ 8 + i], C64_EVEN1[i]);

    /* 2 4-wide butterfly */
    for (i = 0; i < 4; ++i)
    {
        butterfly(&v[0 + i], &v[ 4 + i], C64_EVEN2[i]);
        butterfly(&v[8 + i], &v[12 + i], C64_EVEN2[i]);
    }

    /* 4 2-wide butterfly */
    for (i = 0; i < 16; i += 4)
    {
        butterfly(&v[0 + i], &v[ 2 + i], C64_EVEN3[0]);
        butterfly(&v[1 + i], &v[ 3 + i], C64_EVEN3[1]);
    }

    /* 8 1-wide butterfly */
    butterfly(&v[ 0], &v[ 1], K[0]);
    butterfly(&v[ 2], &v[ 3], K[1]);
    butterfly(&v[ 4], &v[ 5], K[1]);
    butterfly(&v[ 6], &v[ 7], K[2]);
    butterfly(&v[ 8], &v[ 9], K[1]);
    butterfly(&v[10], &v[11], K[2]);
    butterfly(&v[12], &v[13], K[2]);
    butterfly(&v[14], &v[15], K[3]);
}

/**
 * ??
 * Matrixing step:
 * -> seems to use Lee algorithm (or at least a close variant) to compute MDCT
 * ??
 * */
static void matrixing_step(u16 dmem_src, u16 fifo1, u16 fifo2)
{
    s32 v[32];
    s32 t[16]; // temporary values
    int i;

    /* 1 16-wide butterfly */
    for(i = 0; i < 16; ++i)
    {
        v[i]    = *sample_at(dmem_src + REORDERED_OFFSETS[i]);
        v[i+16] = *sample_at(dmem_src + 0x3e - REORDERED_OFFSETS[i]);
        butterfly(&v[i], &v[i+16], C64_ODD[i]);
    }

    /* even indices */
    matrixing_mdct16(v);

    v[6]  <<= 1;
    v[10] <<= 1;
    v[12] <<= 1;
    v[14] <<= 2;

    t[5]  = v[5] + v[4];
    t[2]  = v[8] + v[9];
    t[3]  = v[8] + v[10];
    t[13] = v[13] - t[2] + v[12];
    t[14] = t[3] - v[14];
    t[15] = v[15] - t[2] - v[11];
    
    *(s16*)(mp3data+((fifo1 + 0x000))) = (s16)v[1];
    *(s16*)(mp3data+((fifo1 + 0x040))) = (s16)(v[9] + t[14]);
    *(s16*)(mp3data+((fifo1 + 0x080))) = (s16)(t[5] - v[6]);
    *(s16*)(mp3data+((fifo1 + 0x0c0))) = (s16)(t[13] - v[10]);
    *(s16*)(mp3data+((fifo1 + 0x100))) = (s16)(v[3] - v[2]);
    *(s16*)(mp3data+((fifo1 + 0x140))) = (s16)(v[11] - t[13]);
    *(s16*)(mp3data+((fifo1 + 0x180))) = (s16)(v[7] - t[5]);
    *(s16*)(mp3data+((fifo1 + 0x1c0))) = (s16)t[15];

    *(s16*)(mp3data+((fifo2 + 0x000))) = (s16)(-v[1]);
    *(s16*)(mp3data+((fifo2 + 0x040))) = (s16)t[14];
    *(s16*)(mp3data+((fifo2 + 0x080))) = (s16)(v[4] - v[6]);
    *(s16*)(mp3data+((fifo2 + 0x0c0))) = (s16)(v[12] - v[10] - v[8]);
    *(s16*)(mp3data+((fifo2 + 0x100))) = (s16)(-v[2]);
    *(s16*)(mp3data+((fifo2 + 0x140))) = (s16)(v[8] - v[12]);
    *(s16*)(mp3data+((fifo2 + 0x180))) = (s16)(-v[4]);
    *(s16*)(mp3data+((fifo2 + 0x1c0))) = (s16)(-v[8]);
    *(s16*)(mp3data+((fifo2 + 0x200))) = (s16)(-v[0]);

    /* odd indices */
    matrixing_mdct16(v + 16);

    v[22] <<= 1;
    v[26] <<= 1;
    v[28] <<= 1;
    v[30] <<= 2;

    t[0] = v[16] >> 1;
    t[4] = v[20] + t[0];
    t[5] = v[21] + v[17];
    t[6] = v[22] + t[0] + v[18];
    t[7] = v[23] + t[0] + v[17] + v[19];
    t[10] = v[26] + v[24];
    t[11] = v[27] + v[24] + v[25];
    t[12] = t[4] - v[28];
    t[13] = v[29] - t[12] - t[5];
    t[14] = t[6] - v[30];
    t[15] = v[31] - t[7];
    t[5] = t[4] + t[5];
    t[9] = v[25] + t[10];

    *(s16*)(mp3data+((fifo2 + 0x020))) = (s16)t[14];
    *(s16*)(mp3data+((fifo2 + 0x060))) = (s16)(t[10] - t[6]);
    *(s16*)(mp3data+((fifo2 + 0x0a0))) = (s16)(t[4] - t[10] + v[18]);
    *(s16*)(mp3data+((fifo2 + 0x0e0))) = (s16)(-t[12] - v[18]);
    *(s16*)(mp3data+((fifo2 + 0x120))) = (s16)t[12];
    *(s16*)(mp3data+((fifo2 + 0x160))) = (s16)(v[24] - t[4]);
    *(s16*)(mp3data+((fifo2 + 0x1a0))) = (s16)(t[0] - v[24]);
    *(s16*)(mp3data+((fifo2 + 0x1e0))) = (s16)(-t[0]);
    
    *(s16*)(mp3data+((fifo1 + 0x020))) = (s16)(t[14] + v[17]);
    *(s16*)(mp3data+((fifo1 + 0x060))) = (s16)(t[9] - v[17] - t[6]);
    *(s16*)(mp3data+((fifo1 + 0x0a0))) = (s16)(t[5] + v[18] - t[9]);
    *(s16*)(mp3data+((fifo1 + 0x0e0))) = (s16)(t[13] - v[18]);
    *(s16*)(mp3data+((fifo1 + 0x120))) = (s16)(v[19] - t[13]);
    *(s16*)(mp3data+((fifo1 + 0x160))) = (s16)(t[11] - v[19] - t[5]);
    *(s16*)(mp3data+((fifo1 + 0x1a0))) = (s16)(t[7] - t[11]);
    *(s16*)(mp3data+((fifo1 + 0x1e0))) = (s16)t[15];
}

static void windowing_step(u16 dmem_dst, u16 fifo16_base, unsigned index)
{
    unsigned i;
    u32 offset = 0x10 - index;
    s32 v2, v4, v6;

    for (i = 0; i < 16; ++i)
    {
        idot8(&v2, &v6, (s16*)(mp3data + fifo16_base), (s16*)(WINDOW_LUT + offset));
        // clamp ?
        *sample_at(dmem_dst) = v2 + v6;

        dmem_dst += 2;
        fifo16_base += 0x20;
        offset += 0x20;
    }

    idot8(&v2, &v4, (s16*)(mp3data + fifo16_base), (s16*)(WINDOW_LUT + offset));
    *sample_at(dmem_dst) = (index & 0x1) ? v2 : v4;
    dmem_dst += 2;

    fifo16_base -= 0x40;
    offset  = 0x22f - index;
    for (i = 0; i < 8; ++i)
    {
        idot8(&v2, &v4, (s16*)(mp3data+fifo16_base+0x20), (s16*)(WINDOW_LUT + offset + 0x00));
        v2 -= v4;
        idot8(&v6, &v4, (s16*)(mp3data+fifo16_base+0x00), (s16*)(WINDOW_LUT + offset + 0x20));
        v6 -= v4;
        // clamp ?
        *sample_at(dmem_dst) = v2;
        *sample_at(dmem_dst + 2) = v6;
        
        dmem_dst += 4;
        fifo16_base -= 0x40;
        offset += 0x40;
    }
}

static void apply_gain(u16 mem, unsigned count, s16 gain)
{
    while (count != 0)
    {
        smul(sample_at(mem), gain);
        mem += 2;
        --count;
    }
}

/* global function */

/**
 * Perform the synthesis polyphase filter bank step.
 **/
void mp3_decode(u32 address, unsigned index)
{
    u32 dram_dst, dram_src; /* s6, s5 */
    u16 dmem_dst, dmem_src; /* s3, s7 */
    s16 gains[2];
    unsigned i, j;

    u16 fifo1 = 0x08a0;         /* t6 */
    u16 fifo2 = fifo1 + 0x220;  /* t5 */

    dram_dst = dram_src = address;

    /* read gains */
    memcpy(mp3data+0xce8, rsp.RDRAM+dram_src, 8);
    gains[0] = *(s32*)(mp3data+0xce8) >> 16;
    gains[1] = *(s32*)(mp3data+0xcec) >> 16;

    dram_src += 8;

    for (i = 0; i < 3; ++i)
    {
        dmem_src = 0xcf0; dmem_dst = 0xe70;
        memcpy(mp3data+dmem_src, rsp.RDRAM+dram_src, 0x180);

        for (j = 0; j < 6; ++j)
        {
            fifo1 = fifo16_address(fifo1, index);
            fifo2 = fifo16_address(fifo2, index);

            matrixing_step(dmem_src, fifo1, fifo2);
            windowing_step(dmem_dst, fifo16_address(fifo1,0), index);
            apply_gain(dmem_dst + 0x00, 17, gains[0]);
            apply_gain(dmem_dst + 0x22, 16, gains[index & 0x1]);
                
            swap(&fifo1, &fifo2);
            index = (index - 1) & 0x0f;
            dmem_dst += 0x40; dmem_src += 0x40;
        }

        memcpy(rsp.RDRAM+dram_dst, mp3data+0xe70, 0x180);
        dram_dst += 0x180; dram_src += 0x180;
    }
}

